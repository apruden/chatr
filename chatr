#!/bin/python

import time, json, datetime, os, uuid
from threading import Thread
from flask import Flask, render_template, session, request, send_from_directory, jsonify, url_for, redirect
import flask.json

from pybloomfilter import BloomFilter
from flask_socketio import SocketIO, emit, join_room, leave_room, \
    close_room, rooms, disconnect, send

from flask_social import Social, login_failed
from flask_social.datastore import SQLAlchemyConnectionDatastore
from flask_social.utils import get_connection_values_from_oauth_response
from flask_social.views import connect_handler

from flask_sqlalchemy import SQLAlchemy, BaseQuery
from sqlalchemy_searchable import SearchQueryMixin
from sqlalchemy_utils.types import TSVectorType
from sqlalchemy_searchable import make_searchable

from flask_security import Security, SQLAlchemyUserDatastore, \
    UserMixin, RoleMixin, login_required
from flask_security.utils import login_user, logout_user
from flask_security.core import current_user

from sqlalchemy.ext.declarative import DeclarativeMeta
from geoalchemy2.types import Geometry
from geoalchemy2.functions import ST_Distance
from geoalchemy2.elements import WKTElement, WKBElement
from sqlalchemy.types import JSON
from geoalchemy2.shape import to_shape


#TODO: better encoder logic, public vs private fields
class AlchemyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj.__class__, DeclarativeMeta):
            fields = {}
            for field in [x for x in dir(obj) if not x.startswith('_') and x != 'metadata']:
                data = obj.__getattribute__(field)
                try:
                    json.dumps(data) # this will fail on non-encodable values, like other classes
                    fields[field] = data
                except TypeError:
                    if isinstance(data, WKBElement):
                        fields[field] = 'SRID=4326;%s' % (to_shape(data).wkt,)
                    elif isinstance(data, datetime.date):
                        fields[field] = data.strftime('%Y-%m-%d')
                    else:
                        fields[field] = None
            return fields

        return json.JSONEncoder.default(self, obj)


app = Flask(__name__, static_url_path='/')
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql+psycopg2://chatr:Admin123@localhost/chatr'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SQLALCHEMY_ECHO'] = True

app.config['SECRET_KEY'] = 'secret!'
app.config['SECURITY_POST_LOGIN'] = '/#!/profiles/me'
app.config['SOCIAL_FACEBOOK'] = {
    'consumer_key': '',
    'consumer_secret': ''
}

#app.config['SECURITY_CONFIRMABLE'] = False
#app.config['SECURITY_TRACKABLE'] = False
app.config['SOCIAL_CONNECT_ALLOW_VIEW'] = '/#!/profiles/me'

socketio = SocketIO(app)
db = SQLAlchemy(app)
make_searchable()

roles_users = db.Table('roles_users',
        db.Column('user_id', db.Integer(), db.ForeignKey('user.id')),
        db.Column('role_id', db.Integer(), db.ForeignKey('role.id')))


class Role(db.Model, RoleMixin):
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(80), unique=True)
    description = db.Column(db.String(255))


class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True)
    password = db.Column(db.String(255))
    active = db.Column(db.Boolean())
    confirmed_at = db.Column(db.DateTime())
    roles = db.relationship('Role', secondary=roles_users,
            backref=db.backref('users', lazy='dynamic'))
    connections = db.relationship('Connection',
            backref=db.backref('user', lazy='joined'))


class Criteria(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    query = db.Column(db.String(255))


class Profile(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(255), unique=True)
    gender = db.Column(db.Integer)
    location = db.Column(Geometry(geometry_type='POINT', srid=4326)) # SRID=4326;POINT(0.00 0.00)
    dob = db.Column(db.Date)
    headline = db.Column(db.Text)
    about = db.Column(db.Text)
    photos = db.Column(JSON)
    city = db.Column(db.String(255))

    @property
    def age(self):
        #TODO: better way to calc ages? y1 - y2 ,then months, then days?
        if self.dob:
            return int((datetime.datetime.now().date() - self.dob).days / 365)
        return 0


class Connection(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    provider_id = db.Column(db.String(255))
    provider_user_id = db.Column(db.String(255))
    access_token = db.Column(db.String(255))
    secret = db.Column(db.String(255))
    full_name = db.Column(db.String(255))
    display_name = db.Column(db.String(255))
    profile_url = db.Column(db.String(512))
    image_url = db.Column(db.String(512))
    rank = db.Column(db.Integer)


class Message(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    a = db.Column(db.Integer)
    b = db.Column(db.Integer)
    data = db.Column(JSON)
    sent = db.Column(db.DateTime)
    to = db.Column(db.Integer)
    fro = db.Column(db.Integer)
    read = db.Column(db.DateTime)


class Visit(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    to = db.Column(db.Integer)
    fro = db.Column(db.Integer)
    modified = db.Column(db.DateTime)
    data = db.Column(JSON)
    read = db.Column(db.Boolean)


class CityQuery(BaseQuery, SearchQueryMixin):
    pass


class City(db.Model):
    query_class = CityQuery
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Unicode(255))
    country = db.Column(db.String(255))
    location = db.Column(Geometry(geometry_type='POINT', srid=4326)) # SRID=4326;POINT(0.00 0.00)
    search_vector = db.Column(TSVectorType('name'))


user_datastore = SQLAlchemyUserDatastore(db, User, Role)
security = Security(app, user_datastore)
social = Social(app, SQLAlchemyConnectionDatastore(db, Connection))


@login_failed.connect_via(app)
def on_login_failed(sender, provider, oauth_response):
    connection_values = get_connection_values_from_oauth_response(provider, oauth_response)
    user = user_datastore.create_user(email='', password='') #fill in relevant stuff here
    db.session.commit()
    db.session.add(Profile(id=user.id, username='user%s' % (int(time.time()),)))
    connection_values['user_id'] = user.id
    connect_handler(connection_values, provider)
    db.session.commit()
    login_user(user)


@app.before_first_request
def create_user():
    print 'creating'
    return
    try:
        db.create_all()
        _create_user('admin@test.com', 'password')
    except:
        pass


def _create_user(email, password):
    user = user_datastore.create_user(email=email, password=password)
    db.session.commit()
    db.session.add(Profile(id=user.id, username=email))
    db.session.commit()
    return user


@app.login_manager.unauthorized_handler
def unauth_handler():
    return jsonify(success=False, message='Unauthorized'), 401


@app.route('/api/_logout')
@login_required
def app_logout():
    logout_user()
    return redirect('/')


@app.route('/api/_login')
def app_login():
    #user = User.query.filter_by(email='admin@test.com').first()
    user = User.query.get(int(request.args.get('id')))
    if user:
        login_user(user)
        return jsonify(message='ok')
    else:
        user = _create_user('user%s@test.com' % (request.args.get('id'),), 'password')
        login_user(user)
        return jsonify(message='ok')
        #return jsonify(message='error'), 401


def dumps(obj):
    return flask.json.dumps(obj, cls=AlchemyEncoder)


@app.route('/api/_upload', methods=['POST'])
@login_required
def upload():
    file = request.files['file']
    filename = '%s.jpg' % (uuid.uuid4(),)
    file.save(os.path.join('assets', filename))
    return jsonify(filename=filename)


@app.route('/api/cities')
@login_required
def cities():
    return dumps(City.query.search(request.args.get('q')).limit(10).all())


@app.route('/api/assets/<id>')
@login_required
def assets(id):
    return send_from_directory('assets', id)


BLOOM_PATH = 'visits.bloom'

if os.path.exists(BLOOM_PATH):
    bf = BloomFilter.open(BLOOM_PATH)
else:
    bf = BloomFilter(10**7, 0.001, BLOOM_PATH)


@app.route('/api/profiles/<id>', methods=['GET', 'POST'])
@login_required
def profiles(id):
    if id == 'me':
        id = current_user.id
    profile = Profile.query.get(id)
    if not profile:
        return jsonify(message='not found'), 404
    if request.method == 'GET':
        if current_user.id != id and request.args.get('visitor') and not ((current_user.id, id) in bf):
            visit = Visit(to=id,
                    fro=current_user.id,
                    data= dict(username=request.args.get('visitor')),
                    modified=datetime.datetime.now())
            db.session.add(visit)
            db.session.commit()
            bf.add((current_user.id, id))
        return dumps(profile)
    elif request.method == 'POST':
        request.json.pop('age', None)

        for k, v in request.json.items():
            setattr(profile, k, v)

        db.session.commit()

        main_photo = '%s.jpg' % id

        if os.path.exists(main_photo):
            os.unlink(main_photo)

        try:
            pic = next(x.filename for x in profile.photos if x.isMain)

            if pic:
                os.symlink(main_photo, 'assets/%s' % (pic,))
        except StopIteration:
            pass

        return dumps(profile)

@app.route('/api/search')
@login_required
def search():
    loc = request.args.get('loc').split(';')[1]
    pt = WKTElement(loc, srid=4326)
    ageFrom = request.args.get('ageFrom', 18)
    ageTo = request.args.get('ageTo', 100)

    profiles = Profile.query.filter(
            (Profile.gender == request.args.get('gender', 0)) &
            (Profile.dob >= datetime.datetime.now() - datetime.timedelta(days=365*ageTo)) &
            (Profile.dob <= datetime.datetime.now() - datetime.timedelta(days=365*ageFrom))
            ).filter(ST_Distance(Profile.location, pt) < request.args.get('dist', 50000)).limit(10).all()

    #return models.Point.query.order_by(models.Point.geom.distance_box(pt)).first()

    return dumps(profiles)

@app.route('/api/chats', defaults={'id': None})
@app.route('/api/chats/<id>')
@login_required
def chats(id):
    if id:
        a = int(id)
        b = current_user.id
        (a,b) = (a,b) if a < b else (b,a)
        messages = Message.query.filter_by(a=a, b=b).limit(20).all()
    else:
        to = current_user.id
        messages = Message.query.filter_by(to=to).order_by(Message.a, Message.b, Message.id.desc()).distinct(Message.a, Message.b).limit(20).all()

    return dumps(messages)


@app.route('/api/visits')
@login_required
def visits():
    to = current_user.id
    visits = Visit.query.filter_by(to=to).limit(20).all()
    unread = [v.id for v in visits if not v.read]

    if unread:
        db.session.query(Visit).filter(
                Visit.id.in_(unread)).update({Visit.read: True}, synchronize_session=False)
        db.session.commit()

    return dumps(visits)


@socketio.on('msg')
def sio_send_message(message):
    msg = Message(**message)
    db.session.add(msg)
    db.session.commit()

    if message['to'] in sids:
        message['id'] = msg.id
        emit('msg', message, room=sids[message['to']])


@socketio.on('ack')
def sio_ack_message(ack):
    t = datetime.datetime.now()
    db.session.query(Message).filter(Message.id == ack['id']).update({Message.read: t})
    db.session.commit()

    if ack['to'] in sids:
        ack['read'] = t.strftime('%Y-%m-%dT%H:%M:%SZ')
        emit('ack', ack, room=sids[ack['to']])


sids = {} #user id to sid


@socketio.on('connect')
def sio_connect_handler():
    if current_user.is_authenticated:
        sids[current_user.id] = request.sid


@socketio.on('disconnect')
def sio_isconnect_handler():
    print('Client disconnected')


@app.route('/', defaults={'path': 'index.html'})
@app.route('/<path:path>')
def dist(path):
    return send_from_directory('src/webapp/dist', path)


if __name__ == '__main__':
    try:
        print 'dropping'
        #db.drop_all()
    except:
        pass

    socketio.run(app)
