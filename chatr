#!/bin/python

import time, json, datetime
from threading import Thread
from flask import Flask, render_template, session, request, send_from_directory, jsonify, url_for
import flask.json


from flask_socketio import SocketIO, emit, join_room, leave_room, \
    close_room, rooms, disconnect, send

from flask_social import Social, login_failed
from flask_social.datastore import SQLAlchemyConnectionDatastore
from flask_social.utils import get_connection_values_from_oauth_response
from flask_social.views import connect_handler

from flask_sqlalchemy import SQLAlchemy

from flask_security import Security, SQLAlchemyUserDatastore, \
    UserMixin, RoleMixin, login_required
from flask_security.utils import login_user
from flask_security.core import current_user

from sqlalchemy.ext.declarative import DeclarativeMeta
from geoalchemy2.types import Geometry
from geoalchemy2.elements import WKTElement


class AlchemyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj.__class__, DeclarativeMeta):
            fields = {}
            for field in [x for x in dir(obj) if not x.startswith('_') and x != 'metadata']:
                data = obj.__getattribute__(field)
                try:
                    json.dumps(data) # this will fail on non-encodable values, like other classes
                    fields[field] = data
                except TypeError:
                    fields[field] = None
            return fields

        return json.JSONEncoder.default(self, obj)


app = Flask(__name__, static_url_path='/')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = 'secret!'
app.config['SECURITY_POST_LOGIN'] = '/#!/profiles/me'
app.config['SOCIAL_FACEBOOK'] = {
    'consumer_key': '621936294681039',
    'consumer_secret': '070416545aadaeb30fbf411468d03eac'
}

#app.config['SECURITY_CONFIRMABLE'] = False
#app.config['SECURITY_TRACKABLE'] = False
app.config['SOCIAL_CONNECT_ALLOW_VIEW'] = '/#!/profiles/me'


socketio = SocketIO(app)
db = SQLAlchemy(app)
roles_users = db.Table('roles_users',
        db.Column('user_id', db.Integer(), db.ForeignKey('user.id')),
        db.Column('role_id', db.Integer(), db.ForeignKey('role.id')))


class Role(db.Model, RoleMixin):
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(80), unique=True)
    description = db.Column(db.String(255))


class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True)
    password = db.Column(db.String(255))
    active = db.Column(db.Boolean())
    confirmed_at = db.Column(db.DateTime())
    roles = db.relationship('Role', secondary=roles_users,
            backref=db.backref('users', lazy='dynamic'))
    connections = db.relationship('Connection',
            backref=db.backref('user', lazy='joined'))


class Criteria(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    query = db.Column(db.String(255))


class Profile(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(255), unique=True)
    gender = db.Column(db.Integer)
    location = db.Column(Geometry(geometry_type='POINT', sird=4326))
    dob = db.Column(db.Date())
    headline = db.Column(db.Text())
    about = db.Column(db.Text())
    photos = db.Column(db.Text())
    city = db.Column(db.String(255))


class Connection(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    provider_id = db.Column(db.String(255))
    provider_user_id = db.Column(db.String(255))
    access_token = db.Column(db.String(255))
    secret = db.Column(db.String(255))
    full_name = db.Column(db.String(255))
    display_name = db.Column(db.String(255))
    profile_url = db.Column(db.String(512))
    image_url = db.Column(db.String(512))
    rank = db.Column(db.Integer)


class Message(db.Model):
    a = db.Column(db.Integer, primary_key=True)
    b = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text())
    sent = db.Column(db.DateTime())
    to = db.Column(db.Integer)
    fro = db.Column(db.Integer)


user_datastore = SQLAlchemyUserDatastore(db, User, Role)
security = Security(app, user_datastore)
social = Social(app, SQLAlchemyConnectionDatastore(db, Connection))


@login_failed.connect_via(app)
def on_login_failed(sender, provider, oauth_response):
    connection_values = get_connection_values_from_oauth_response(provider, oauth_response)
    user = user_datastore.create_user(email='', password='') #fill in relevant stuff here
    db.session.commit()
    db.session.add(Profile(id=user.id, username='user%s' % (int(time.time()),)))
    connection_values['user_id'] = user.id
    connect_handler(connection_values, provider)
    db.session.commit()
    login_user(user)


@app.before_first_request
def create_user():
    db.create_all()
    user = user_datastore.create_user(email='admin@test.com', password='password')
    db.session.commit()
    db.session.add(Profile(id=user.id, username='admin'))
    db.session.commit()


@app.login_manager.unauthorized_handler
def unauth_handler():
    return jsonify(success=False, message='Unauthorized'), 401


@app.route('/api/_login')
def app_login():
    user = User.query.filter_by(email='admin@test.com').first()
    if user:
        login_user(user)
        return jsonify(message='ok')
    else:
        return jsonify(message='error'), 401


def dumps(obj):
    return flask.json.dumps(obj, cls=AlchemyEncoder)


@app.route('/api/profiles/<id>', methods=['GET', 'POST'])
@login_required
def profiles(id):
    if id == 'me':
        id = current_user.id
    profile = Profile.query.get(id)
    if not profile:
        return jsonify(message='not found'), 404
    if request.method == 'GET':
        return dumps(profile)
    elif request.method == 'POST':
        for k, v in request.json.items():
            setattr(profile, k, v)

        db.session.commit()

        return dumps(profile)

@app.route('/api/search')
@login_required
def search():
    pt = WKTElement('POINT({0} {1})'.format(lon, lat), srid=4326)
    ageFrom = request.args.get('ageFrom', 18)
    ageTo = request.args.get('ageTo', 100)

    profiles = Profile.query.filter(
            (Profile.gender == request.args.get('gender', 0)) &
            (Profile.dob >= datetime.datetime.now() - datetime.timedelta(days=365*ageTo)) &
            (Profile.dob <= datetime.datetime.now() - datetime.timedelta(days=365*ageFrom))
            ).filter(func.ST_Distance(Profile.location, pt) < request.args.get('dist')).limit(10).all()

    #return models.Point.query.order_by(models.Point.geom.distance_box(pt)).first()

    return dumps(profiles)

@app.route('/api/chats')
@login_required
def chats():
    a = request.args.get('a')
    b = request.args.get('b')
    to = request.args.get('to')

    if a and b:
        (a,b) = (a,b) if a < b else (b,a)
        messages = Message.query.filter_by(a=a, b=b).limit(20).all()
    elif to:
        messages = Message.query.filter_by(to=to).limit(20).all()
    else:
        return jsonify(error='not found'), 404

    return dumps(messages)


@socketio.on('msg')
def sio_send_message(message):
    db.session.add(Message(**message))
    db.commit()

    if message['to'] in sids:
        send(message, room=sids[message['to']])


sids = {} #user id to sid


@socketio.on('connect')
def sio_connect_handler():
    if current_user.is_authenticated:
        sids[current_user.id] = request.sid


@socketio.on('disconnect')
def sio_isconnect_handler():
    print('Client disconnected')


@app.route('/', defaults={'path': 'index.html'})
@app.route('/<path:path>')
def dist(path):
    return send_from_directory('src/webapp/dist', path)


if __name__ == '__main__':
    socketio.run(app)
